
 /**
 * decode a input audio file, return the file's fingerprint
 *
 **/

#include <stdlib.h>  
//#include <math.h>

#include <libavcodec/avcodec.h>  
#include <libavformat/avformat.h>  
#include <libavutil/fifo.h>

#include "./libfooid/fooid.h"
 
 /**
 * retrun:
 *		-1 : error. could not decode or generate fingerprint.
 *
 **/
int main( int argc, char *argv[])  
{  
	char * filename = NULL; 

	//check input parameters	
	if( argc < 1)
	{
		printf("argc = %d \n", argc );
		printf("[useage:] %s ***.mp3 \n", argv[0] );
		return 0;
	}
	else
	{
		filename = argv[1]; 
	}

	/*debug
	**fingerprint calculate algrithom fooid is different in x86 and arm platform
	*/
	float a=( 1.0f/32768.0f - (1e-15));
	printf("size of (float) = %d \n", sizeof( float ) );
	printf("size of int = %d \n", sizeof( int ) );
	printf("1.0f/32768.0f = %f \n ",  a );
	float x1 = 0.5;
	float x2 = -0.5;
	printf(" fooid round(0.5)=%f, round(-0.5)=%f\n", round(x1), round(x2) );
	x1 = 0.3;
	x2 = -0.3;
	printf(" fooid round(0.3)=%f, round(-0.3)=%f \n", round(x1), round(x2) );
	x1 = 0.6;
	x2 = -0.6;
	printf(" fooid round(0.6)=%f, round(-0.6)=%f \n", round(x1), round(x2) );
	printf("hahah\n");
	//register encoders&decoders
    av_register_all();  
  
    AVFormatContext * pFormatCtx = avformat_alloc_context();   // file's continer of contex. 
   	 
     // 
	//open input file
    if (avformat_open_input(&pFormatCtx, filename, 0, NULL) != 0)  
    {  
        printf("could not open file");  
        return -1;  
    }  
    if (av_find_stream_info(pFormatCtx) < 0) // 检查在文件中的流的信息  
    {  
		printf("error! can not find the stream's info \n");
        return -1;  
    }  

    av_dump_format(pFormatCtx, 0, filename, 0); // 显示pfmtctx->streams里的信息  
      

	// find the first audio stream
    int audioStream = -1;  
    for (int i = 0; i < pFormatCtx->nb_streams; ++i)  //找到音频、视频对应的stream  
    {  
        if (pFormatCtx->streams[i]->codec->codec_type == AVMEDIA_TYPE_AUDIO)  
        {  
            audioStream = i;  
            break;  
        }  
    }  
    if (audioStream == -1) //if could not find any audio. 
    {  
        printf("could not find any  audio stream in input file\n");  
        return -1;  
    }  
      
	// get audio decoder's context.
    AVCodecContext * pCodecCtx = NULL;
	pCodecCtx= pFormatCtx->streams[audioStream]->codec;   
      
	// find correct decoder base on the context.
    AVCodec * pCodec = NULL ;  
    pCodec = avcodec_find_decoder(pCodecCtx->codec_id);    
    if (pCodec == NULL)  
    {  
		printf("error! no Codec found \n" );
        return -1;  
    }  
  
    // Inform the codec that we can handle truncated bitstreams  
    // bitstreams where frame boundaries can fall in the middle of packets  
    if (pCodec->capabilities & CODEC_CAP_TRUNCATED)  
    {  
        pCodecCtx->flags |= CODEC_CAP_TRUNCATED;  
    }  

	//add to correct decoder's output data format.
//	pCodecCtx->request_sample_fmt = AV_SAMPLE_FMT_S16;
  
    // 打开解码器  
    if (avcodec_open(pCodecCtx, pCodec) < 0)  
    {  
		printf("error! avcodec_open failed. \n ");
        return -1;  
    }  

	printf(" 	[bit_rate]    = %d \r\n", pCodecCtx->bit_rate);
	printf(" 	[sample_rate] = %d \r\n", pCodecCtx->sample_rate);
	printf(" 	[channels]    = %d \r\n", pCodecCtx->channels);
	printf(" 	[code_name]   = %s \r\n", pCodecCtx->codec->name);
	printf(" 	[block_align] = %d\n",pCodecCtx->block_align);
	printf("    [sample_fmt]  =%d \n", pCodecCtx->sample_fmt );


    // Hack to correct wrong frame rates that seem to be generated by some   
    // codecs  
    FILE * fp = fopen("out.pcm", "wb");  
	long start = clock(); //开始解码时间   
    
    AVPacket packet; 
   	AVFrame * pFrame = NULL;  
	int frame_num = 2 * pCodecCtx->sample_rate * pCodecCtx->channels;
	//short inbuf [frame_num];   
	int count =0;
	int read_seconds = 0; //fooid need data in 1 second chips.
	int gotFrame = 0;
    int out_size = AVCODEC_MAX_AUDIO_FRAME_SIZE; 
	//int buf_size = AVCODEC_MAX_AUDIO_FRAME_SIZE;
	//uint8_t inbuf [frame_num];   //typedef unsigned char uin8_t
	uint8_t *inbuf;   //typedef unsigned char uin8_t
	inbuf = (uint8_t * )malloc( frame_num * sizeof( uint8_t ) );
	printf("size of short: %d, size of uint8_t:%d \n", sizeof(short), sizeof(uint8_t) );
	AVFifoBuffer *fifo;
//	fifo = av_fifo_alloc( AVCODEC_MAX_AUDIO_FRAME_SIZE * 2);
	fifo = av_fifo_alloc( frame_num * 2 );
	av_init_packet( &packet );

  	printf(" before decode, out_size=%d,frame_num=%d,  MAX_FRAME_SIZE=%d\n",\
			out_size, frame_num, AVCODEC_MAX_AUDIO_FRAME_SIZE);
//*******************************************************************************
	// initial for fingerprint libfooid
	t_fooid *fooid = fp_init( pCodecCtx->sample_rate, pCodecCtx->channels );
	int result = -1;
//*******************************************************************************

	/**
	* test a mp3 file,
	*/
	if( !pFrame )
	{
		if( ! ( pFrame = avcodec_alloc_frame() ) )
			{
				fprintf(stderr, "while allocate memory for Frame.\n");  
               	exit(1);  
			}
	} //avcodec_get_frame_defaults(pFrame ); //alredy add in avcodec_alloc_frame()

    while(av_read_frame(pFormatCtx, &packet) >= 0) //pFormatCtx中调用对应格式的packet获取函数  
    {  
        if (packet.stream_index == audioStream) //Detect read packet is audio stream? 
        {  
        	out_size = AVCODEC_MAX_AUDIO_FRAME_SIZE ;
            while ( packet.size > 0)  
            {  	// decode audio
               	//int len = avcodec_decode_audio3(pCodecCtx, (short *)inbuf, &out_size, &packet); 
                int len = avcodec_decode_audio4(pCodecCtx, pFrame, &gotFrame, &packet);
                if( len < 0 )
				{
					fprintf( stderr, "Error while decoding\n");
					exit(1);
				}
               if ( gotFrame )  
                {  //if a frame has been decoded, output it 
					out_size = av_samples_get_buffer_size( NULL, pCodecCtx->channels,
																pFrame->nb_samples,
																pCodecCtx->sample_fmt, 1 );
					//printf("pFrame->nb_samples= %d, out_size=%d \n",pFrame->nb_samples, out_size );
					av_fifo_generic_write( fifo, pFrame->data[0], out_size, NULL );
                }  

				while( av_fifo_size( fifo ) >= frame_num )
				{
					read_seconds++ ;
					//printf("  seconds=%d, fifo_size=%d\n", read_seconds, av_fifo_size(fifo) );

				 	av_fifo_generic_read( fifo, inbuf, frame_num, NULL );
                    fwrite(inbuf, 1, frame_num, fp);  //write pcm to file: ***.pcm
				//*************************************************************
					result = fp_feed_short( fooid,(short * ) inbuf, (frame_num/2) );
					if( result < 0 )
					{
						printf(" error in calculate fingerprint process!\n" );
					}
				//*******************************************************************

				}
				packet.size -= len; 
				packet.data += len;
				packet.dts = 
				packet.pts = AV_NOPTS_VALUE;
            }  
        }  
		//************************************
		if( read_seconds >= 100 )
		{
			break;
		}
		//*************************************
    } 
          
	//************************************************************
	unsigned char * fingerprint = malloc( fp_getsize (fooid ) );
	//result = fp_calculate( fooid, read_seconds*100, fingerprint );
	result = fp_calculate( fooid, read_seconds*100, fingerprint );
	if( result < 0 )
	{ 
		printf("error, failed to calculate fingerprint!\n" );
	}
	else
	{
		/*
		for( int i=0; i<fp_getsize(fooid ); i++ )
		{
			if( !( i%32 ) )
			{
				printf("\n");
			}
			printf("%02x ", (int)fingerprint[i] );
		}
		printf("\n");
		*/
		for( int i=0; i<fp_getsize(fooid ); i++ )
		{
			printf("%02x", (int)fingerprint[i] );
		}
	}
	free( fingerprint);
	fp_free( fooid );
	//************************************************************
	long end = clock();
	printf("\n cost time :%f\n",(double)(end-start)/(double)CLOCKS_PER_SEC);

	free( inbuf );
    fclose(fp);  
    //av_free_packet(&packet);  
 	//av_free( pFrame );
    avcodec_close(pCodecCtx);  
    avformat_close_input(&pFormatCtx);  
    return 0;  
}  
